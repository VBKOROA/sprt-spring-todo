# 헥사고날 아키텍처 리팩토링 대화 요약 (2025-08-05)

## 1. 핵심 목표
기존 스프링 부트 프로젝트를 **헥사고날 아키텍처(Hexagonal Architecture)** 로 리팩토링하는 것을 목표로 대화를 진행했습니다. 이 과정에서 에이전트는 아키텍처 원칙을 설명하고 코드 개선 방향을 제안하는 역할을 수행했습니다.

## 2. 주요 논의 및 결정 사항

### 가. 아키텍처 원칙 및 개념
- **패키지 구조**: 전통적인 계층형 구조에서 헥사고날 아키텍처의 `adapter`, `application`, `domain` 구조로 재구성했습니다.
- **의존성 규칙**: 모든 의존성은 외부(`adapter`)에서 내부(`application`, `domain`)로 향해야 한다는 원칙을 확인했습니다. (`Adapter` -> `Application` -> `Domain`)
- **DTO vs Command**: 외부 세계(API)와 맞닿는 `adapter` 계층의 DTO(`TodoCreateReq`)와, `application` 계층의 유스케이스 입력을 나타내는 Command(`CreateTodoCommand`)를 분리하는 것의 중요성에 대해 논의했습니다. 이는 계층 간 결합도를 낮추기 위한 의도적인 설계입니다.
- **도메인 순수성**: `domain` 계층은 특정 프레임워크(`@Component` 등)에 의존하지 않는 순수한 POJO로 유지하는 것을 지향하며, 필요한 빈(Bean)은 별도의 `@Configuration` 파일에서 생성하기로 했습니다.
- **실용적 관점**: `domain` 계층이 `application/port` 계층의 인터페이스(추상화)에 의존하는 것은 실용적인 관점에서 허용 가능한 설계임을 확인했습니다.

### 나. 도메인 설계
- **값 객체(Value Object)의 책임**: `Password` VO가 단순히 값을 담는 것을 넘어, 스스로 비밀번호 일치 여부를 확인하는 `matches()` 메소드를 갖도록 하여 "Tell, Don't Ask" 원칙을 적용하고 캡슐화를 강화하는 방향으로 개선하기로 했습니다.
- **도메인 내 유효성 검증**: `@NotNull`, `@Size` 와 같은 Java 표준 유효성 검증 어노테이션(`jakarta.validation-api`)을 `domain` 계층에서 사용하는 것은, 특정 프레임워크가 아닌 표준 스펙에 대한 의존이므로 실용적인 관점에서 허용하기로 했습니다.

### 다. 애플리케이션 계층 설계 (UseCases & Facade)
- **단일 책임 원칙(SRP)**: 거대한 서비스 클래스를 각 기능에 맞는 개별 유스케이스(`AddCommentUseCase`, `CreateTodoUseCase` 등)로 분리했습니다.
- **퍼사드 패턴(Facade Pattern)**: 여러 유스케이스들을 직접 주입받는 대신, `TodoUseCaseFacadeImpl`라는 퍼사드를 통해 컨트롤러에 단일 진입점을 제공하기로 했습니다. 이는 컨트롤러의 코드를 단순화하고 내부 구현을 캡슐화하는 효과가 있습니다.
- **퍼사드 구현 방식 논의**:
    1. **초기 아이디어**: 퍼사드 메소드가 특정 `UseCase` 객체 자체를 반환하고, 컨트롤러가 그 객체의 `execute()` 메소드를 다시 호출하는 방식.
        - **문제점**: `TodoUseCase is a raw type` 경고 발생, 컨트롤러의 책임 증가, 코드의 직관성 저하.
    2. **최종 제안/결론**: 퍼사드의 각 메소드가 **직접 해당 유스케이스를 실행하고 최종 결과(도메인 객체)를 반환**하는 방식으로 구현하기로 결정했습니다. 이 방식이 타입 안정성이 높고, 캡슐화가 잘 되며, 퍼사드 패턴의 본래 의도에 더 부합합니다.

---
이상의 내용을 바탕으로 리팩토링을 계속 진행할 수 있습니다.